# mruby on zig

Write in mruby and compile by zig

## Concept and Goals

This is an attempt to write the main program in mruby and compile it by zig to be an executable. Here are the steps to set up the development environment.

### 1. Compile mruby

- Download [mruby](https://mruby.org/). It is currently version 3.4.0.
- Unzip and run `rake test all` to generate headers (mruby.h) and library (libmruby.a) at `mruby-3.4.0/build/host/`.

You may need to use `CC="zig cc" rake test all` if there are errors on C macros.
You can customize the mruby under `build_config` and gembox under `mrbgems`.

### 2. Translate mruby headers

This can be automated by `build.zig`, but it requires some fixes. Therefore, I will do so manually.

- Create a header file, `mruby_headers.h`, to include the necessary headers like this:

```
#include <mruby.h>
#include <mruby/irep.h>

extern uint8_t rb_main[]; // this refers to mruby bytecode in C later
```

- Translate it into zig code:

```
$ zig translate-c -lc -I mruby-3.4.0/build/host/include mruby_headers.h > src/mruby_h.zig
```

### 3. Fix opaque error

Based on [mruby.zig](https://github.com/jethrodaniel/mruby.zig), you need to change this line of generated `src/mruby_h.zig` from:

```
    gc: mrb_gc = @import("std").mem.zeroes(mrb_gc),
```

to this one:

```
    gc: u128 = @import("std").mem.zeroes(u128),
```

### 4. Use build.zig to convert mruby file to bytecode in C automatically

Assuming there is a mruby file at `src/main.rb`. Add this in `build.zig`

```
    // Generate mrb bytecode from src/main.rb
    const mruby_path = "mruby-3.4.0/build/host/";
    const mrbc = b.addSystemCommand(&.{
        mruby_path++"bin/mrbc",
        "-Brb_main", // this "rb_main" is the same as in mruby_headers.h
    });

    const mrb_c = mrbc.addPrefixedOutputFileArg("-o", "main.c");
    mrbc.addFileArg(b.path("src/main.rb"));
```

### 5. Include everything in build.zig

Add the generated bytecode in C to zig executable:

```
    exe.addCSourceFile(.{
        .file = mrb_c,
        .flags = &.{},
    });

    exe.addIncludePath(b.path(mruby_path++"include/"));
    exe.addObjectFile(b.path(mruby_path++"lib/libmruby.a"));
    exe.linkLibC();
    exe.step.dependOn(&mrbc.step);
```

### 6. Run mruby code as executable

The minimal code to run mruby bytecode is:


```
const c = @import("mruby_h.zig");

// This is to fix linking errors
export var edata: u8 = 0;
export var end: u8 = 0;
export var etext: u8 = 0;

pub fn main() !void {
    const mrb = c.mrb_open();
    _ = c.mrb_load_irep(mrb, c.rb_main);
    defer c.mrb_close(mrb);
}
```

And run it with `zig build run`.

## Call Zig function from mruby

Here is an example. Add it into `src/root.zig`:

```
export fn zig_add(mrb: ?*c.mrb_state, self:c.mrb_value) c.mrb_value {
    _ = self;
    var a: c.mrb_int = 0;
    var b: c.mrb_int = 0;

    _ = c.mrb_get_args(mrb, "ii", &a, &b);
    return c.mrb_fixnum_value(a+b);
}

pub fn registerFunctions(mrb: *c.mrb_state) void {
    const kernel = mrb.kernel_module;
    c.mrb_define_method(
        mrb,
        kernel,
        "zig_add",
        zig_add,
        c.MRB_ARGS_REQ(2),
    );
}
```

From `main.zig`, call `registerFunction()` to register the function so that mruby can find it.

In mruby, run `zig_add(3,4)` will work.

## Call mruby from Zig

Just use mruby C API.

## Example: mruby fiber with zig http client function

See `src/fiber_ping.rb` and `src/root.zig`.

It uses mruby fiber for cooperative scheduling and call zig function which fetches a url as a way of pinging.
If it fetches successfully, it will wait 5 seconds (not in real time) to ping (fetch) again.
Otherwise, it will ping per second. It is just a dummy example that you can use mruby for neat logics and zig for io.
